<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /* 
        私有作用域和私有变量
        在全局作用域形成之后才有可能形成私有组用域，私有作用域是属于全局作用域的一部分；
        在函数执行的时候就会产生私有作用域
        函数执行会形成一个私有的栈内存(私有作用域)
         */


        // function fn() {

        // }


        // fn()


        // 函数的创建
        // 1、先开辟一个堆内存，生成一个16机制的空间地址
        // 2、把函数里的代码以字符串的格式存储进去
        // 3、把空间地址返回到值存储区

        // 函数的执行
        // 1、首先开辟一个私有的作用域
        // 2、形参赋值
        // 3、变量提升
        // 4、代码从上往下执行
        // 5、当前做作用域是否销毁

        // var a = 12;
        // function fn(num){
        //     console.log(num);
        // }
        // fn(10);

        // var a = 12;
        // let b = 12;
        // function fn() {
        //     // fn的私有作用域
        //     var a = 13; // 在私有作用域里创建的变量是私有变量
        //     let b = 12;
        //     console.log(a)
        // }
        // fn()

        // 在私有作用域里创建的变量就是私有变量
        // let const var function 形参变量

        // function fn(num){
        //     let a = 12;
        //     const b =10;
        //     var s = 100;
        // }
        // fn(10);

        // var a = 10;
        // function fn(a){
        //     console.log(a); // 100
        // }
        // fn(100);

        // var a = 100;
        // function fn(){
        //     var b = 100;
        //     console.log(a); // 100
        // }
        // fn();
        // console.log(b); // un  b is not defined  

        // var num = 100;
        // function fn(num) { // 100 101
        //     console.log(num++); // 100
        // }
        // fn(num);
        // console.log(num); // 100

        //作用域连  闭包

            /* 
            num = 1
            s = 2
            fn = af0
            f = af1
             */
        let num = 1;
        let s = 2;
        function fn() { //af0
            /* 
            s = 100
            f = af1
             */
            let s = 100;
            function f() { // af1

                console.log(num, s); // 1 100
            }
            return f  // af1
        }
        let f = fn(); // af1
        f()

        // 执行函数，在函数使用一个变量，先看自己的作用域中有没有这个变量，如果有就直接用，如果没有就往上一级作用域查找，如果上一级也没有，那就往上一级的上一级查找，知道找到全局作用域为止，如果全局组用域也没有，那就该报错了
        // 这种一级一级往上查找的机制就是作用域链机制

        // 上一级作用域：函数在哪定义的，那他的上一级作用域就是谁

        // f函数是在fn函数里创建的，所以他的上一级作用域就是fn，fn是在全局作用域创建的，那他的上一级作用域就是全局


        // 闭包-->函数执行形成的私有作用域就是闭包，他可以保护里边的变量不收外界干扰

        function fn(){
            let a = 100;
        }
        fn();
        a++;
        console.log(a) // a is not

        // 作用域链
        // 上一级作用域
        // 闭包

    </script>
</body>

</html>